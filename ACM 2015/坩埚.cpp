#include<stdio.h>   
#include<stdlib.h>   
#include<malloc.h>  

typedef int ElemType;/*单项链表的声明*/

typedef struct PolynNode
{
	int coef; // 系数  搜索 
	int expn; // 指数   
	struct PolynNode *next;
}
PolynNode, *PolynList;/*正位序(插在表尾)输入n个元素的值，建立带表头结构的单链线性表*/
/*
--------------------------------------
		|		|		|		|
		|conf	|expen	|next	|
		|		|		|		|---------
		|		|		|		|		 |	
---------------------------------------	 |
	-------------------------------------
	|  --------------------------------
	|	|		|		|		|
	|	|conf	|expen	|next	|
	-->	|		|		|		|--------->NULL
		|		|		|		|		 
	   ---------------------------------
上图是原始状态， 现在我们要插入一个多项式（2， 3）  2 * x^3;
首先我们新建这样的一个节点， 保存上上述数值   

用以下的代码 
PolynNode * temp = (PolynNode*)malloc(sizeof(PolynNode));
这里新建了一个节点 暂时用temp来指向它， 然后我们将数值填进去
temp->conf = 2;temp->expn = 3;
现在这个temp节点就是我们所需要向链表中添加的节点， 下面就是添加的过程

--------------------------------------
		|		|		|		|
		|conf	|expen	|next	|
		|		|		|		|---------
		|		|		|		|		 |
---------------------------------------	 |
	-------------------------------------
	|  --------------------------------
	|	|		|		|		|  
	|	|conf	|expen	|next	|
	->	|		|		|		|---------   在这里我们将这个NULL 断开接到temp节点中
		|		|		|		|		 |	 具体代码： P-> next = temp; temp->next = NULL;
	   --------------------------------- |   P是原始链表的终点 然后我们将P链接到新建的temp上， 然后temp的下一个是NULL
	------------------------------------
	|   --------------------------------------
	|		 |		|		|		|
	|		 |conf	|expen	|next	|
	------>	 |		|		|		|--------->NULL
			 |		|		|		|		 
	   ---------------------------------------
		插入完成
*/


/*指数系数一对一对输入*/
void CreatePolyn(PolynList &L, int n)
{
	int i;
	PolynList list, q;
	list = L = (PolynList)malloc(sizeof(PolynNode)); // 生成头结点   
	list->next = NULL;
	for (i = 1; i <= n; i++)
	{
		q = (PolynList)malloc(sizeof(PolynNode));
		scanf_s("%d %d", &q->coef, &q->expn);    //指数和系数成对输入   
		list->next = q;
		list = list->next;
	}
	list->next = NULL;
}
// 初始条件：单链表L已存在   
// 操作结果: 依次对L的每个数据元素调用函数vi()。一旦vi()失败,则操作失败  
/*
下面是打印链表的过程， 我们先画一个链表
	   	 -		-	   -	  -		 -	    -																
------->| |--->| |--->| |--->| |--->| |--->| |--->NULL
         -		-      -      -      -      -
				↑假设现在P指向它
这里我们先打印出来P直接指向的元素（你之前写的是函数指针， 那玩意我都不太敢用）第104行
然后我们判断P后面是不是还有东西（105行）， 有的话我们就打印加号（为了和后面的链接起来）（106行） 没有的话就跳过
						
		 -		-	   -	  -		 -	    -
------->| |--->| |--->| |--->| |--->| |--->| |--->NULL
		 -		-      -      -      -      -
				↑P刚才直线它
现在我们打印完了之后， P这个节点已经用完了， 我们将P向后平移一个
用如下代码
P = P->next//  P改为  P的下一个元素（107行）
如果P变为了NULL代表到终点了  直接退出就好了， 否则继续向下打印
*/
void PolynTraverse(PolynList L)
{
	PolynList p = L->next;
	while (p != NULL)
	{
		printf("%dX^%d", p->coef, p->expn);
		if (p->next != NULL)
			printf(" + ");   //“+”号的输出，最后一项后面没有“+”   
		p = p->next;
	}
	printf("\n\n");
}

/*    多项式相加，原理：归并        */
/* 参数：两个已经存在的多项式       */
/* 返回值：归并后新的多项式的头结点 */
/*

链表A；			 ----		-----	   -----	  -----		 ------	     -------
		------->|1，2 |--->|3，4 |--->|5，6 |--->|7，8 |--->|9，10 |--->|10，11 |--->NULL
				 ----		-----      -----      -----      ------      -------
链表B：
				 -----		-----	   -----	  -----		 
		------->|2，3 |--->|4，5 |--->|6，7 |--->|8，8 |--->NULL
				 -----		-----      -----      -----      
现在我们将A B合并到C中

////////////下面是具体过程//////////////////////
首先C是空的
		------->NULL;
然后我们比较A，B链表的首节点， A的次数是2， B的次数是3  A < B， 所以我们把A的首节点拿到C中
现在A变成了：
				 -----	    -----	   -----	  ------	   -------
		------->|3，4 |--->|5，6 |--->|7，8 |--->|9，10 |--->|10，11 |--->NULL
				 -----      -----      -----      ------      -------
B不变：
				 -----		-----	   -----	  -----
		------->|2，3 |--->|4，5 |--->|6，7 |--->|8，8 |--->NULL
				 -----		-----      -----      -----
C变成了
				 ------
		------->|1， 2 |--->NULL;
				 ------		
现在A的首节点次数是4， B的首节点的次数是3     B < A， 所以我们把B的首节点拿下来 放到C中
重复上面的过程， 直到如下

A变成了：
				 -----		------	    -------
		------->|7，8 |--->|9，10 |--->|10，11 |--->NULL
				 -----      ------      -------
B变成了：
				 -----
		------->|8，8 |--->NULL
				 -----
C变成了： 
		太TMD的长了 老子不画了  自己理解这来 和上边的一样
在这这个时候我们发现 A和B的首元素的次数相同了， 在这种情况下我们把两个节点都摘下来 系数相加
A变成了
				 ------	    -------
		------->|9，10 |--->|10，11 |--->NULL
				 ------      -------
B变成了

		------->NULL

C变成了
								   -----					
		太TMD的长了 老子不画了--->|15, 8|--->NULL
								   -----
现在有出现了新的情况  B这个链表没了 但是A还有  
解决这个问题的方法就是
把A剩下的全部链接到C上

A变成了
				 
		没了
				
B变成了

		------->NULL

C变成了
								   -----	  ------	  ------
		太TMD的长了 老子不画了--->|15, 8|--->|9，10 |--->|10，11 |--->NULL
								   -----      ------	  ------
终于完了
下面讲代码
203 204行 分别找到pa, pb，链表A和B的首元素；
205行 给 待插入的链表C的首元素 找好位置
206行 当两个链表都不为空的时候
		|-
		|	207 - 213 当A的首元素系数小于B的首元素系数（对应上文注释129 - 141行） A首元素摘下来放到C中
如此循环|	215 - 219 当B的首元素系数小于A的首元素系数（对应上文注释142行） B首元素摘下来放到C中
		|	210 - 227 当A的首元素系数等于B的首元素系数（对应上文注释144 - 167行） AB首元素摘下来相加放到C中
		|-
当有一个链表为空的时候退出第206行的while循环
如果还有一个链表不是空（注释第168 - 184行）的情况
那么我们找到那个不为空的链表229行， 然后将他插入到链表C的尾部
*/


PolynList MergeList(PolynList La, PolynList Lb)
{
	PolynList pa, pb, pc, Lc;
	pa = La->next;
	pb = Lb->next;
	Lc = pc = La;   // 用La的头结点作为Lc的头结点   
	while (pa&&pb)
	{
		if (pa->expn < pb->expn)
		{
			PolynNode *temp = (PolynNode *)malloc(sizeof(PolynNode));
			temp->coef = pa->coef, temp->expn = pa->expn;
			pc->next = temp;             //如果指数不相等，pc指针连上指数小的结点，   
			pc = temp;
			pa = pa->next;             //指向该结点的指针后移   
		}
		else if (pa->expn > pb->expn)
		{
			PolynNode *temp = (PolynNode *)malloc(sizeof(PolynNode));
			temp->coef = pb->coef, temp->expn = pb->expn;
			pc->next = temp;               //pc指针连上指数小的结点，   
			pc = temp;
			pb = pb->next;               //指向该结点的指针后移   
		}
		else   //(pa ->expn == pb->expn )   
		{
			PolynNode *temp = (PolynNode *)malloc(sizeof(PolynNode));
			temp->coef = pb->coef + pa->coef, temp->expn = pb->expn;    //指数相等时，系数相加   
			pc->next = temp;
			pc = temp;
			pa = pa->next;             //两指针都往后移   
			pb = pb->next;
		}
	}
	if (pa != NULL)// 插入剩余段 
		pc->next = pa;
	else
		pc->next = pb;   
	return Lc;
}


void main()
{
	PolynList ha, hb, hc;
	printf("非递减输入多项式ha， 成对输入5个数据\n");
	CreatePolyn(ha, 5);   // 正位序输入n个元素的值   
	printf("非递减输入多项式hb， 成对输入5个数据\n");
	CreatePolyn(hb, 5);   // 正位序输入n个元素的值   
	printf("多项式ha :");
	PolynTraverse(ha);
	printf("多项式hb :");
	PolynTraverse(hb);
	hc = MergeList(ha, hb);
	PolynTraverse(hc);
}

/*

--------------
|			|
|			|
|			|
|			O	<----------
|		   丿\   
|			λ 
|
|
|
|


*/
